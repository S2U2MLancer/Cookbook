# 目录
-------------------------------------------------------------------------------------
* [shell内置命令说明](#shell内置命令说明)
* [bash\ builtin](#bash\ builtin)
* [date命令](#date命令)
* [ls命令](#ls命令)
* [lsof命令](#lsof命令)
* [find命令详解](#find命令详解)
	* [find\ 路径\ 选项\ 操作](#find\ 路径\ 选项\ 操作)
	* [常用操作的意义](#常用操作的意义)
	* [演示实例](#演示实例)
* [BASH特殊字符](#BASH特殊字符)
* [linux按键说明](#linux按键说明)
* [shell提示符](#shell提示符)
* [issue类的代码意义](#issue类的代码意义)
* [bash的环境设定文件](#bash的环境设定文件)
	* [login时读取的文件](#login时读取的文件)
	* [non-login时读取的文件](#non-login时读取的文件)
* [变量](#变量)
* [变量参数](#变量参数)
* [变量的高级扩展](#变量的高级扩展)
	* [测试变量存在的用法](#测试变量存在的用法)
	* [取字符串的用法](#取字符串的用法)
	* [取字符串的用法](#取字符串的用法)
	* [字符串替换用法](#字符串替换用法)
	* [取变量名称列表](#取变量名称列表)
* [shell算术运算方法](#shell算术运算方法)
* [流程控制](#流程控制)
	* [if条件判断](#if条件判断)
	* [case条件判断](#case条件判断)
	* [for循环](#for循环)
	* [while循环](#while循环)
	* [until循环](#until循环)
	* [select语法](#select语法)
* [注意事项](#ATTN)
* [文件判断式](#文件判断式)
* [字符串判断式](#字符串判断式)
* [算式的判断式](#算式的判断式)
* [函数](#函数)
* [命令行的位置参数](#命令行的位置参数)
* [文件的操作方法](#文件的操作方法)
* [信号的用法](#信号的用法)
* [正则表达式](#正则表达式)
* [sed和awk](#sed和awk)
	* [sed\ 简单示例](#sed\ 简单示例)
	* [awk/gawk\ 简单示例](#awk/gawk\ 简单示例)
* [进程状态代码](#进程状态代码)
* [调整进程的优先级](#调整进程的优先级)
* [历史命令扩展的用法](#历史命令扩展的用法)
-----------------------------------------------------------------------------------

# shell内置命令说明：
```
set：设定shell的属性；不加任何选项和参数，它会显示所有的shell变量和函数的内容。set -o：显示目前shell所有的属性的开关状态。
set -o/+o 属性名  ：修改该属性模式。
shopt：设定shell的行为模式，同set -o。
多个命令的执行：
;  ：各命令执行的结果不影响其他命令。
&& ：前一个命令成功执行才能执行下一个。
|| ：前一个命令未执行成功，执行下一个。
```

## bash builtin
```
:  永远返回为空 :>list.txt
.  从当前shell中执行操作
break	退出for，while，until，case
cd	
continue  退出当前循环，执行下次循环
echo  打印信息到标准输出
eval  读取参数，执行结果命令
exec  执行命令，但不在当前shell
exit  退出当前shell
export  导出变量，使当前shell可用
pwd  
read  从标准输入读取一行文本
命令  命令解释
readonly  设置变量为只读
return  退出函数并带有返回值（0-255之间的值）
set  控制各种参数到标准输出的显示
shift  命令行参数向左偏移一个
test  条件测试
times  显示用户脚本或命令的运行时间，第一行给出shell消耗时间，第二行给出命令运行消耗时间
trap  捕获信号时运行指定命令
ulimit  显示或设置shell资源
umask  显示或设置默认文件创建模式
unset  取消变量或函数
wait  等待直到子进程运行完毕，报告终止
type  查询命令是否驻留系统以及命令类型
tr
cut
sort
uniq
basename
dirname
tail
cat
join
expand -t 将tab改成space
echo -e 启用转义字符，-n不使用换行符
delare 设置变量属性
```


## date命令
```
常用的：
date +%Y%m%d
date --date='2 days ago' +%Y%m%d
```

## ls命令
```
ls -F
无标识表示一般文件，
* 可执行文件
@ soft link
= socket文件
| pipe文件
```

## lsof命令
```
lsof列出所有打开的文件
lsof -c httpd列出某个程序打开的文件信息
lsof -c httpd -c mysql列出多个程序打开的信息。
lsof -u username某个用户打开的文件信息
lsof -g gid 某个组打开的文件信息
lsof -u username -c httpd 某个用户及某个程序打开的文件信息
lsof -u ^root非root用户打开的文件
lsof -p pid 某个进程打开的文件
lsof -i 所有的网络连接
lsof -i tcp所有的tcp连接
lsof -i:3306某个端口的连接情况
lsof -a -u username -i某个用户的所有action的连接
```

## find命令详解
* find 路径 选项 操作
```
常用选项的意义
name  ：按文件名查找
perm  ：按文件权限查找
prune  ：可以使find不在当前指定的目录中查找，同时使用-depth，那么该选项将被忽略
user  ：按文件宿主查找
group  ：按文件所属群组查找
mtime -n +n  ：按文件更改时间查找，-n表示文件更改时间距今在n天之内，+n表示文件更改时间距今在n天前
nogroup  ：查找无有效群组的文件，文件所属组不在/etc/groups中
nouser  ：查找无有效宿主的文件，文件宿主不在/etc/passwd中
-newer file1 ! file2  ：查找更改时间比file1新但比file2旧的文件
type  ：按文件类型查找
size n:[c]  ：查找文件长度为n块的文件，有c时表示文件长度以字节计
depth  ：查找文件时，先查找当前目录中的文件，然后在子目录中找
-path -prune ：指定需要忽略的目录
```
* 常用操作的意义
```
print  ：打印出匹配文件
exec  ：对匹配的文件执行该参数所给出的shell命令。命令形式为'command' {} \;
ok  ：和-exec的作用相同，只不过以更安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都给出提示，让用户来确定是否执行。
```

* 演示实例
```
find / -name 't*' -perm 744 -print
find / -mtime -90 -print 打印修改90天以内的文件。
find / -type f -name "rc*" -exec ls -l {} \;
find / -mtime -3 -ok rm {} \;
find / -path "/usr/local/" -prune -o -print 忽略/usr/local目录
```

## BASH特殊字符
```
#	：注释
;	：命令分隔符
;;	：终止case选项
.	：等价于source命令，是一个bash的builtin
.	：作为文件名的一部分。作为目录的话代表当前目录。
.	：作为正则表达式的的一部分，用来匹配任何的单个字符。
"	：部分引用，"STRING"阻止了一部分特殊字符。
'	：全引用，'STRING'阻止了全部特殊字符。
\	：转义字符
/	：文件名路径分隔符，或除法操作
`	：后置引用，命令替换
:	：空命令，是一个bash的builtin，返回值是0，shell返回的true。还可以作为分隔符。
!	：取反操作，是bash的一个关键字
*	：万能匹配字符，文件名匹配（专有名词叫file globbing），正则中的.。也可以做乘法。
?	：测试操作，在一个确定的表达始终，用?来测试结果。在参数替换中，测试一个变量是否被set了。
?	：在file globbing中和在正则中一样匹配任意的单个字符。
$	：变量替换。正则中作为行结束符。
${}	：参数替换
$*,$@	：位置参数
$?	：退出状态变量
$$	：进程ID变量，保存运行脚本进程ID
()	：命令组，在()中的命令列表将作为一个子shell来运行。
{xxx,yyy,zzz...}	：大括号扩展 
{}	：代码块即内部组，即创建了一个匿名函数，与函数不同的是，在其中声明的变量对于脚本其他部分的代码来说还是可见的。
{}与()不同的是，{}不能开启一个新shell。
{}\;	：路径名，一般都在find中使用。;用来结束find的-exec选项。
[]	：test。[是builtin的一部分，不是test命令的一个链接。
[[]]	：test。
[]	：数组元素，在正则中也可以做字符范围；如：[a-z][1-9]
(())	：数学计算的扩展
>&>>&>><	：重定向
<<	：重定向，用在here document
<<<	：重定向，用在here string
<,>	：ASCII比较
\<,\>	：正则中的单词边界，如：grep '\<the\>' textfile
|	：管道
>|	：强制重定向（即使设置了noclobber）将强制的覆盖一个现存文件。
||	：逻辑或
&	：后台运行命令
&&	：逻辑与
-	：命令选项。也可用于重定向stdin或stdout。也可以是之前工作的目录，也是减法操作。
=	：等号，也用来比较字符串
+	：加号，也用在正则中。命令选项，特定的命令中+用来打开特定的选项。
%	：取模，也是正则中。
~	：home
~+	：当前工作目录，相当于$PWD
~-	：之前的工作目录，相当于$OLDPWD
=~	：用于正则，正则表达式匹配。
^	：行首，
```

## linux按键说明：
```
C-k:先按住CTRL键不放，然后再按k键。
M-k:先按ESC键，放开再按k键。
空格：分割命令或者是变量，$IFS对于某些命令输入的特殊变量分割域，默认使用空格，想保留空格则使用引用。
C-b：光标后退
C-c：终止前台工作
C-d：logout
C-h：backspace，删除光标前边的字符。
C-z：终止前台工作。
C-G：beep.将响铃.
C-I：就是tab 键.
C-j：新行
C-m：回车
C-a：移到行首。
C-e：移到行尾。
C-q：继续，这个继续的标准输入在一个终端里。
C-s：挂起，这个被挂起的stdin在一个终端里，用C-q恢复
C-v：当输入字符时，C-v允许插入控制字符。
C-z：终止前台工作
C-b：回移一个字符。
C-f：后移一个字符。
M-b：回移一个单词。
M-f：后移一个单词。
C-l：清屏。
C-h：删除光标左边的字符。
C-d：删除光标右边的字符。
M-d：删除光标之后的单词。
C-w：删除光标之前的单词
C-k：删除光标右边所有的字符。
C-u：删除光标之前的所有字符。
C-_：恢复之前的操作。（按住CTRL不放，然后再同时按住shift+_）
C-y：把之前删除的字符或字符串粘到光标所在位置。
M-操作次数：指定操作次数。
C-r：查找之前执行过的命令，如果查找到按enter键执行，按C-g中断执行。
C-p：调出前一个命令。
C-n：调出下一个命令。
M-<：调出第一个历史命令。
M->：移到最后一个历史命令的后面。
M-/：命令自动补齐。
M-@：补齐主机名。
M-$：补齐变量名。
M-~：补齐账号名。
```

## shell提示符
```
PS1--主提示符--PS1=\S-\V$;echo $PS2--此提示符
\h--主机名（第一个点之前）
\H--完整主机名
\u--使用者帐号名称
\s--shell的名称
\d--周 月 日
\t--24小时制的时间[HH:MM:SS]
\A--24小时制的时间格式[HH:MM]
\T--12小时制的时间[HH:MM:SS]
\@--12小时制的时间格式[am/pm]
\w--完整工作目录
\W--工作目录最后一节
\!--此命令的历史指令编号
\#--此命令的编号
\v--bash的版本号
\V--bash的完整版本
\$--提示字符，如果是root为#，否则就是$
```

## issue类的代码意义
```
\d--本地时间的日期
\l--显示第几个终端机界面
\m--显示硬件的等级
\n--显示主机的网络名称
\O--显示域名
\r--系统的版本
\t--显示本地时间
\S--系统的名称
\v--系统的版本
```

## bash的环境设定文件：
### login时读取的文件 
```
/etc/profile  ~/.bash_profile  ~/.bash_login  ~/.profile  /usr/share/bash-completion/completions/*  /etc/locale.conf  /etc/profile.d/*.sh
```
### non-login时读取的文件  
```
~/.bashrc  /etc/man_db.conf  ~/.bash_history  ~/.bash_logout
```

## 变量
```
设置变量时，使用单引号或双引号的区别：
使用双引号会把引号里面的变量替换成变量值，简言之；双引号中，替换变量，替换命令执行结果，替换算术运算结果。
单引号不会替换，所见即所得。
```

## 变量参数：
```
$1-$n  ：位置参数，10以上用{}即${10}
$*  ：所有的位置参数组成的一个字符串
$@  ：所有的位置参数每一个参数是一个字符串
$#  ：位置参数的个数
$-  ：shell目前使用的功能选项
$?  ：前一个命令执行结果值。
$$  ：当前shell的进程号
$!  ：上一个后台程序的进程号
$_  ：1、脚本执行时，bash的绝对路径；2、上一个命令执行时的最后一个位置参数；3、检查邮件时，为邮件文件名。
shift ：重新分配位置参数，shift一次，向左移动一个位置
使用declare调整变量的属性
建立数组的方法：
a[0]=5
a[1]=10
...
或
b=(5 10 ...)
显示数组元素：echo ${b[2]}
显示数组所有元素：echo ${b[@]} 或 echo ${#b[*]}
取得数组元素个数：echo ${#b[@]}或 echo ${#b[*]}
```

## 变量的高级扩展
### 变量扩展的基本是：${变量名称}、$(命令)、 $((算数式))
### 测试变量可以判断文件是否存在。

#### 测试变量存在的用法：
```
${待测变量-默认值}	：变量不存在，传回默认值。存在传原值。
${待测变量:-默认值}	：变量不存在或为空，传默认值。存在传原值。等价于if；then else fi
${待测变量:=默认值}	：变量不存在或为空，则设为默认值，存在传原值。
${待测变量:?提示信息}	：变量不存在或为空，则显示变量名称和提示信息，并停止执行脚本。
${待测变量:+真值}	：变量存在值非空，传真值。若传空值。
```

#### 取字符串的用法：
```
${变量:位置起点}	：从指定位置开始截取字符串到结束。
${变量:位置起点:长度}	：从指定位置开始截取字符串长度。
${@:起点}		：从起点开始取后面所有的位置参数。
${@:起点:个数}		：从起点开始取后面位置参数的个数。
${#变量名}		：传变量值的字符串长度。等价于expr命令：
```

#### 字符串删除用法：
```
${变量#样式}		：由前面开始，对比变量值，删除符合最短的字符串。
${变量##样式}		：同上，删最长的。
${变量%样式}		：由后面开始，删最短的。
${变量%%样式}		：同上，删最长的。
```

#### 字符串替换用法：
```
${变量/样式/替换字符串}	：变量中，有符合样式的字符串（最长的），则使用替换字符串取代。
${变量//样式/替换字符串}：所有符合样式的字符串，使用替换字符串取代。
${变量/样式/}		：删除第一个符合样式的字符串。
${变量//样式/}		：删除全部符合样式的字符串。
```

#### 取变量名称列表
```
${!开头字符串@}或${!开头字符串*}	：取出以开头字符串开头的变量名。
${!数组变量[@]}或${!数组变量[*]}	：取出数组变量所有的索引。
```

## shell算术运算方法：
```
$((算数式)) r=$((2+5*8))
expr 算数式 r=$(expr 4 + 5) 
$[算数式]   r=$[ 4 + 5 ]
declare -i 变量=算数式	declare -i r=8+16
let 算数式  let r=8+16
表达式中有变量的算术扩展方法：
$((${j:-8}+2))  ：如果变量j不存在或空，则8+2.
```

## 流程控制
### if条件判断
```
if 条件测试; then
	命令区域
fi

if 条件测试; then
	命令区域1
else
	命令区域2
fi

if 条件测试1; then
	命令区域1
elif 条件测试2;then
	命令区域2
else
	命令区域3
fi
```

### case条件判断
```
case 待测项 in
	样式串行1) 命令区域1;;
	样式串行2）命令区域2;;
	...
	*)命令区域;;
esac
```

### for循环
```
for 变量 in 串行
do
	命令区域
done
for ((初始条件;终止条件;异动项))
do
	命令区域
done
无穷循环
for ((;1;))
do
	命令区域
done
```

### while循环
```
while 条件测试
do
	命令区域
done
无穷循环
while ((1))/true/:
do
	命令区域
done
```

### until循环
```
until 条件测试
do
	命令区域
done
只有until是测试的假值。
无穷循环
until ((0))/false
do
	命令区域
done
```

### select语法
```
select 选项变量 in 串行
do
	命令区域
done
```
## ATTN
```
条件判断式中[[]]、test、[]的差别：
[[]]更自由，不需要担心特殊字符对条件判断的影响，里面的运算符不需要加转义字符。
test和[]是shell内置命令，特殊字符需要加上转义符。
```

### 文件判断式：
```
-a 文件  ：文件存在
-b(block) 文件  ：文件存在，且是设备文件
-c(character) 文件  ：文件存在，且是字符文件
-d(directory) 文件  ：文件存在，且是目录
-e(exist) 文件  ：文件存在
-f(file) 文件  ：文件存在，且是一般文件
-g(gid) 文件  ：文件存在，且有set group id属性
-h 文件  ：文件存在，且是符号链接
-k 文件  ：文件存在，且有sticky位的属性
-p(pipo) 文件  ：文件存在，且是管道文件
-r(read) 文件  ：文件存在，且可读
-s(size) 文件  ：文件存在，大小大于0
-t(terminal) 文件描述符  ：文件描述符是开启的，且链接了某个终端
-u(uid) 文件  ：文件存在，且有set user id属性
-w(writer) 文件  ：文件存在，且可写
-x(execute) 文件  ：文件存在，且可执行
-O(owner) 文件  ：文件存在，且为有效使用者id拥有
-G(group) 文件  ：文件存在，且为有效群组id拥有
-L(link) 文件  ：文件存在，且是符号链接
-S(socket) 文件  ：文件存在，且是socket文件
-N 文件  ：文件存在，且上次读取后，曾修改过
文件1 -nt 文件2  ：文件1比文件2新，或文件1存在，文件2不存在
文件1 -ot 文件2  ：文件1比文件2旧，或文件1不存在，文件2存在
文件1 -ef 文件2  ：文件1和文件2参考到相同的设备和inode编号
```

## 字符串判断式
```
-z 字符串  ：字符串长度为0
-n 字符串  ：字符串长度不为0
字符串  ：字符串长度不为0
字符串1==字符串2  ：两个字符串相同
字符串1=字符串2  ：两个字符串相同
字符串1!=字符串2  ：两个字符串不相同
字符串1<字符串2  ：字符串1小于字符串2
字符串1>字符串2  ：字符串1大于字符串2
字符串1 =~ 字符串2  ： 字符串1是否包含字符串2，字符串2是字符串1的子字符串
```

## 算式的判断式
```
参数1 -eq 参数2  ：参数1和参数2的值相等
参数1 -ne 参数2  ：参数1和参数2的值不等
参数1 -lt 参数2  ：参数1的值小于参数2的值
参数1 -le 参数2  ：参数1的值小于或等于参数2的值
参数1 -gt 参数2  ：参数1的值大于参数2的值
参数1 -ge 参数2  ：参数1的值大于或等于参数2的值
```

## 函数
```
function 函数名称()
{
	命令区域
}
或者
函数名称()
{
	命令区域
}
或者
function 函数名称
{
	命令区域
}
常用第二种。
函数的调用直接写出函数名即可。
函数参数的传递，函数名为$0,所传递的参数为$1,$2...以此类推。
函数的返回值，在函数体中任意地方使用return 语句，只能是0-256之间的一个整数，保存在$?变量中。当shell执行到return语句时会跳出函数的执行，继续执行主script中的其他语句。
```

## 命令行的位置参数：
```
$0  ：脚本文件名
$1  ：第一个参数
$2  ：第二个参数
$3  ：第三个参数
... ：以此类推
${10}：第十个参数
${n} ：第n个参数
$#  ：参数的个数
$@  ：所有以空格隔开的参数
$*  ：所有参数组成的字符串
```


## 文件的操作方法：
```
fd<>文件  ：开启文件，指定文件代码为fd，开启的文件可供读写
fd<&-	  ：关闭转向输入文件。
fd>&-	  ：关闭转向输出文件。
n<&m 	  ：复制转向输入的文件代码m，存成文件代码n，使n连接至m
n>&m	  ：复制转向输出的文件代码m，存成文件代码n，使n连接至m
fd<文件	  ：转向输入
fd>文件   ：转向输出
fd>|文件  ：同上，但不用理会noclobber选项。
fd>>文件  ：追加文件
&>文件或>&文件  ：标准错误伴随标准输出做转向。
>文件 2>&1：同上
Here Document转向：
fd<<标记
资料
....
....
....
标记（EOF）
```

## 信号的用法：
```
kill -l  ：参看信号列表。
HUP(1)   ：重新启动进程
INT(2)   ：中断程序
QUIT(3)  ：以内核转储的方式离开程序
TERM(15) ：终止进程
KILL(9)  ：强制删除进程
STOP(19) ：暂停进程
CONT(18) ：继续执行
TSTP(20) ：在终端中暂停进程
ABRT(6)  ：放弃进程，并转存内核（core dump）信息
SEGV(11) ：内存区段错误，并转存核心信息
```

## 正则表达式
### 正则表达式是一种描述的方法，一种小型的语言，可表示某种样式或若干种样式的组合，它的威力在于仅需几个简单的符号，便可代表许多字符串共同的样子。
```
正则表达式的语法：
. 代表任意一个字符
^ 位置在行的开头
$ 在行的结尾
[...] 字符串行中的一个字符
[^A-Z] 除了大写字母之外的一个字符
* 前面的字符有0个或以上
\{...\} 指定前面的字符的个数
\(...\) 把比对符合的字符串暂时保存起来
```

## sed和awk
### sed 简单示例
```
sed是一种非交互式的流编辑器，动态编辑文件。
sed '1,4d' file  ：把第一到第四行删除，显示剩下的。
sed '/La/d' file ：把含有La的行删除，显示剩下的。
sed '/[0-9]\{3\}/d' file  ：把含有“3位数”的行删除，显示剩下的。
sed '/^$/d' file  ：删除file中的空白行。
sed '/La/!d' file  ：把不含La的行删除，显示剩下的。
sed -n '/La/p' file  ：把含有La的行显示出来。-n强制不显示不符合的数据。
sed -n 's/La/Oo/p' file  ：使用Oo替换第一个出现的La。
sed -n 's/La/Oo/gp' file  ：使用Oo替换全部的La。
sed -n 's/La//p' file  ：把每一行第一个出现的La替换成空。
sed -n 's/\(La\)/\1Oo/p' file  ：若数据行含有La，则第一个出现的La会替换成LaOo，然后再显示这些含有La的数据行。
sed -n '/AAA/s/234/567/p' file  ：找到含有AAA的行，将234替换成567
```
### awk/gawk 简单示例
```
awk是一种可以处理数据、产生格式化报表的语言。工作方式是读取数据文件，将每一行数据视为一条记录（record）每笔记录以字段分隔符分成若干字段，然后输出各个字段的值。
awk "样式" 文件 ：把符合样式的数据行显示出来。
awk '{操作}' 文件 ：对每一行都执行{}中的操作。
awk '样式{操作}' 文件 ：对符合样式的数据行，执行{}中的操作。
awk '/La/' file  ：显示含La的行
awk '{ print $1, $2 }' file  ：显示file每一行的第一和第二个字段
awk '/La/{ print $1, $2 }' file  ：含有La的行的第一及第二字段显示出来
awk -F: '/^swolice/{ print $3, $4 }' /etc/passwd  ：使用-F指定:为分隔符，显示swolice的第三第四字段
awk -F: 'BEGIN{OFS="+++"}/^swolice/{ print $1, $2, $3, $4, $5 }' /etc/passwd  ：以：为分隔符，+++为输出字段分隔符，将swolice的第1-5列显示出来
```

## 进程状态代码：
```
D  ：不可中断的休眠（通常是进行输出输入I/O的进程）
R  ：可执行的（在执行队列）
S  ：等待接受工作（休眠）
T  ：被追踪或被停止
W  ：分页（只适用于Linux核心2.4以前的不版本）
X  ：死亡
Z  ：僵尸
<  ：高优先级的工作
N  ：的优先级的工作
L  ：已分页锁定于内存中
s  ：一个session leader
+  ：在前台的进程群组中
```

## 调整进程的优先级
```
优先级nice值（-20~20）-20~0只有root才能更改，0~20可由一般用户更改。调整nice值的两个命令：nice、renice
nice运用于尚未执行的程序，renice用在已执行的进程。
工作控制：ctrl+Z暂停该进程；bg把该进程丢到后台执行；jobs列出目前的工作；fg把进程拉到前台；disown移除工作；wait等待子进程结束，传回最后一个命令的执行状态；suspend暂停目前的shell；
工作符号：
+  ：目前的工作
-  ：前一个工作
%%或%+  ：调出现在的工作
%-  ：调出前一个工作
%n  ：调用编号n的进程，置于前台执行
%n &  ：调用编号n的进程，置于后台执行
%?sl  ：调用含有sl字符串的工作
%./sl  ：调用文件名开头是./sl的工作
```

## 历史命令扩展的用法：
```
!n  ：调用编号n的历史命令 
!-n  ：调用倒数n个的历史命令
!!  ：执行前一个历史命令
!字符串  ：执行最近一个以“字符串”开头的历史命令
!?字符串?  ：执行最近一个含有“字符串”的历史命令
^字符串1^字符串2^  ：将前一个历史命令中的“字符串1”换成“字符串2”，然后执行替换后的命令
!#  ：在命令行中，到目前为止所键入的字符串
!!:$  ：取得前一个命令的最后一个参数
!ls:1  ：找出最近一个以ls开头的命令的第一个参数
!ls:*  ：找出最近一个以ls开头的命令的所有参数
!!:3-5  ：找出前一个命令中，介于字符串3至字符串5的参数
!!:s/字符串1/字符串2/  ：将前一个命令中的“字符串1”替换成“字符串2”，然后执行替换后的命令
!ls:s/tmp/root/  ：找出最近一个以ls开头的命令，并把其中的tmp换成root
!!:h  ：删除后面的文件名
!!:t  ：删除前面的目录
!!:p  显示前一个命令，但不执行
```
